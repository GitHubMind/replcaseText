package lib

import (
	"encoding/json"
	"io/ioutil"
	"log"
	"regexp"
	"strings"
)

type RegFileAddes struct {
	FileAddes        string
	StrMap           map[string]string
	AutoGeneratedTmp AutoGenerated
}
type AutoGenerated []struct {
	Reg string `json:"regAddress"`
}

func (tra *RegFileAddes) ReadJsonFile() {
	data, err := ioutil.ReadFile(tra.FileAddes)
	if err != nil {
		log.Println("error:", err)
	} else {
		log.Println(tra.FileAddes, "json status is success")
	}
	err = json.Unmarshal(data, &tra.AutoGeneratedTmp)
	if err != nil {
		log.Println("error:", err)
	} else {
		//加载匹配规则
		tra.StrMap = make(map[string]string, 0)
		tra.StrMap["*"] = "[^\\s]*"
		for i, _ := range tra.AutoGeneratedTmp {
			tra.AutoGeneratedTmp[i].Reg = tra.PretreatRegCompile(tra.AutoGeneratedTmp[i].Reg)

		}
	}
}

// 把igenore 常用的处理成能正常解析的
func (tra *RegFileAddes) PretreatRegCompile(regStr string) string {
	//预处理
	strReg := "^" + regStr
	for key, value := range tra.StrMap {
		if strings.Contains(regStr, key) {
			reg, err := regexp.Compile("[" + key + "]+")
			if err != nil {
				log.Println("faild to regRule :", err)
			}
			strReg = reg.ReplaceAllString(regStr, value)
			//log.Println(strReg)
		}
	}
	return strReg
}

func reg(regstr, str string) bool {
	regstr = "^" + regstr
	reg, err := regexp.Compile(regstr)
	if err != nil {
		log.Println("faild to regRule :", err)
	}
	return reg.Match([]byte(str))
}
func (tra *RegFileAddes) RegName(dir, file, root string) (result bool) {

	// delete outmenet of layer     "1/xxx/aaa"=> xxx/aaa

	dir = dir[strings.Index(dir, root)+len(root):]
	for _, value := range tra.AutoGeneratedTmp {

		// AutoGeneratedTmp is already handle
		//if strings.Contains(value.Reg, "/") {
		//catalog
		result = reg(value.Reg, dir+"/"+file)
		//} else {
		//	//file
		//	result = reg(value.Reg, file)
		//}
		if result == false {
			return
		}
	}
	return
}
